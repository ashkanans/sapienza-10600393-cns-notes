%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                            %
%                    Read constant commands                  %
%                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\input{resources/constants/images path/IMAGE_PATH.tex}
\input{resources/constants/images path/IMAGE_NAMES.tex}
\input{resources/constants/images path/IMAGE_REFS.tex}
\input{resources/constants/configuration/GENERAL_CONFIGURATION.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                            %
%                       Custom Commands                      %
%                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Usage: \imageCaptionTable{image path}{image caption}{image label}{text}
% - The first argument should be the path to the image file in any format.
% - The second argument should be the caption of the image to be displayed.
% - The third argument should be the label of the image.
% - The fourth argument should be the text to be displayed on the right side of the image.
% - The resulting table will have the image displayed on the left (with the caption and label) and the text on the right.

\newcommand{\imageCaptionTable}[4]{%
	\begin{tabular}{l l}
		\includegraphics[width=0.5\textwidth, caption={#2}, label={#3}]{#1} & \centering
		\begin{varwidth}[t]{0.8\textwidth}
			\configuratedText{#4}
		\end{varwidth}
	\end{tabular}
}

% Inserts a small image in the middle of a text
% Usage: \smallimage[optional scale]{image file name}
% - The optional scale argument (default 0.5) can be used to adjust the size of the image.
% - The image file should be in the same directory as the LaTeX document.

\newcommand{\smallimage}[2][0.03]{
	\includegraphics[width=#1\linewidth]{#2}
}


% Creates a new figure with an image centered on the page, and adds a caption and label for reference.
% Usage: \sectionCenteredfigure[optional scale]{image file name}{caption text}{label}
% - The optional scale argument (default 0.9) can be used to adjust the width of the image.
% - The image file should be in the same directory as the LaTeX document.
% - The caption text should describe the contents of the image.
% - The label should be a unique identifier for the figure, used for referencing it later in the text.

\newcommand{\sectionCenteredfigure}[4][0.9]{
	\begin{figure}[H]
		\centering
		\fbox{\includegraphics[width=#1\linewidth]{#2}}
		\caption{#3}
		\label{fig:#4}
	\end{figure}
}


% Creates a new block of justified text with a specified font and font size.
% Usage: \generalText{font family}{font size}{text}
% - The font family argument specifies the font to be used (e.g., Times New Roman, Arial, etc.).
% - The font size argument specifies the size of the font (e.g., 12pt, 14pt, etc.).
% - The text argument should contain the text to be justified.
% - The resulting block of text will be fully justified (i.e., aligned with both the left and right margins).

\newcommand{\customText}[3]{%
	\par\begingroup
	\setlength{\parindent}{0pt}%
	\linespread{1.3}%
	\fontsize{#2}{#2}%
	\fontfamily{#1}\selectfont #3%
	\par\endgroup%
}

% Creates a new block of justified text with the font size and font style of configuration file.
% Usage: \generalText{text}
% - The font family argument is specfied by \userManualSimpleTextStyle 
% - The font size argument is specified by \userManualSimpleTextSize
% - The text argument should contain the text to be justified.
% - The resulting block of text will be fully justified (i.e., aligned with both the left and right margins).

\newcommand{\configuratedText}[1]{%
	\par\begingroup
	\setlength{\parindent}{0pt}%
	\linespread{1.3}%
	\selectfont #1%
	\par\endgroup%
}

% Defines a new command for referencing figures.
% Usage: \figref{label}
% - The argument should be the label of the figure to be referenced.
% - The resulting output will be in the format "(Figure <number>)", where <number> is the number of the referenced figure.
% - The label should be defined using \label{fig:<label>} command in the figure environment.
% - The \hyperref command creates a hyperlink to the referenced figure.
% - The \ref* command produces only the number of the referenced figure, without the preceding "Figure" text.

\newcommand{\figref}[1]{(\hyperref[fig:#1]{Figure \ref*{fig:#1}})}

% Creates a new table with an icon and its name.
% Usage: \customTable{icon path}{icon name}
% - The first argument should be the path to the icon file in PNG format.
% - The second argument should be the name of the icon to be displayed.
% - The resulting table will have the icon displayed on the left and its name on the right.

\newcommand{\iconNameTable}[2]{%
	\begin{tabular}{l l}
		\includegraphics[width=0.03\textwidth]{#1} & \centering 
		\begin{varwidth}[t]{0.8\textwidth}
			\configuratedText{#2}
		\end{varwidth}
	\end{tabular}
}

% Creates a new table with an icon and its name.
% Usage: \customTable{icon path}{icon name}
% - The first argument should be a text.
% - The second argument should be a text.
% - The resulting table will have the text displayed on the left and a text on the right.

\newcommand{\textTextTable}[3][2cm]{%
	\begin{tabular}{p{#1} p{\dimexpr0.90\textwidth-#1}}
		\configuratedText{#2}
		&
		\begin{varwidth}[t]{\linewidth}
			\configuratedText{#3}
		\end{varwidth}
	\end{tabular}
}

% Creates a new table with an icon, its name, and its description.
% Usage: \iconNameDescriptTable{icon path}{icon name}{icon description}
% - The first argument should be the path to the icon file in PNG format.
% - The second argument should be the name of the icon to be displayed.
% - The third argument should be a description of the icon.
% - The resulting table will have the icon displayed on the left, its name in the middle, and its description on the right.
% - The table has three columns with widths of 0.1, 0.3, and 0.5 times the text width, respectively.
% - The second and third columns are aligned to the left.

\newcommand{\iconNameDescriptTable}[3]{%
	\begin{tabular}{p{0.05\textwidth} p{0.2\textwidth} m{0.6\textwidth}}
		\includegraphics[width=0.03\textwidth]{#1} & \raggedright \configuratedText{#2} & \justify \configuratedText{#3} \
	\end{tabular}
}

% Creates a new table with an text, its name, and its description.
% Usage: \textDescriptTable{text}{text name}{text description}
% - The first argument should be the text to be displayed on the left.
% - The second argument should be the name of the text.
% - The third argument should be a description of the text.
% - The resulting table will have the text displayed on the left, its name in the middle, and its description on the right.
% - The table has three columns with widths of 0.1, 0.3, and 0.5 times the text width, respectively.
% - The second and third columns are aligned to the left.

\newcommand{\textDescriptTable}[3]{%
	\begin{tabular}{m{0.1\textwidth} m{0.1\textwidth} m{0.5\textwidth}}
		\raggedright \configuratedText{#1} & \raggedright \configuratedText{#2} & \raggedright \configuratedText{#3} \
	\end{tabular}
}

% Creates a new block of two columns with an image on the left and justified text on the right.
% Usage: \twocolumns{optional scale}{image file name}{caption text}{font family}{font size}{text}

% - 1: The optional scale argument (default 0.9) can be used to adjust the width of the image.
% - 2: The image file should be in the same directory as the LaTeX document.
% - 3: The caption text should describe the contents of the image.
% - 4: The font family argument specifies the font to be used (e.g., Times New Roman, Arial, etc.).
% - 5: The font size argument specifies the size of the font (e.g., 12pt, 14pt, etc.).
% - 6: The text argument should contain the text to be justified.

\newcommand{\twoColumns}[6]{
	\begin{minipage}[t]{0.50\textwidth}
		\customText{#4}{#5}{#6}
	\end{minipage}\hfill
	\begin{minipage}[r]{0.45\textwidth}

	\end{minipage}
}

\documentclass[\userManualSimpleTextSize]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{geometry}
\usepackage{tocloft}
\usepackage{booktabs}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{times}
\usepackage{wrapfig}
\usepackage{array}
\usepackage{varwidth}
\usepackage{float}
\usepackage{titlesec}
\usepackage{ragged2e}
\usepackage{todonotes}

% Use the new command to set the font sizes and titleformat settings
\myheadingstyles

% Customize hyperlinks in the document
\hypersetup{
	colorlinks=true, % enable colored hyperlinks
	linkcolor=black, % set the color of internal links to black
	filecolor=magenta, % set the color of links to local files to magenta
	urlcolor=blue, % set the color of links to URLs to blue
	bookmarks=true, % enable the creation of bookmarks in the PDF file
}

\geometry{
	a4paper, % set paper size to A4
	left=2cm, % set left margin to 2cm
	right=2cm, % set right margin to 2cm
	top=2.5cm, % set top margin to 2.5cm
	bottom=2.5cm % set bottom margin to 2.5cm
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                                            %
%                    Document Starts Here                    %
%                                                            %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
	
	\begin{center}
		\begin{figure}[h]
			\centering
			\includegraphics[width=0.4\linewidth]{\cnsFiveTwelve}
		\end{figure}
		\vspace{1cm} 
		{\fontsize{28}{34}\selectfont \textbf{Cybersecurity}}
	\end{center}

	\vspace{1cm} 
	
	\begin{center}
	{\fontsize{22}{28}\selectfont \textbf{Professor: F. d'Amore}}
	\end{center}

	\vspace{1cm} 

	\textcolor{blue!60!black}{\rule{\linewidth}{2pt}}
	
	\vspace{10cm} 
	
	\begin{center}
	\textbf{A.Y. 2022/23}
	\end{center}

	\thispagestyle{empty}
	
	\newpage
	
	\myTOC

	\newpage
	\section{Introduction and terminologies}
	
	\newpage
	\section{Symmetric Encryption}
	\configuratedText{Secret key cryptography involves the use of a single key. Given a message (the plaintext) and the key, encryption produces unintelligible data which is about the same length as the plaintext was.\\
	Secret key cryptography is sometimes referred to as \textbf{conventional cryptography} or \textbf{symmetric cryptography}.\\
	Secret key encryption schemes require that both the party that does the encryption and the party that does the decryption share a secret key. We will discuss two types of secret key encryption schemes:
	\begin{itemize}
	\item \textbf{Stream Ciphers}: This uses the key as a seed for a pseudorandom number generator, produces a stream of pseudorandom bits, and $\oplus$ s (bitwise exclusive ors) that stream with the data. Since $\oplus$ is its own inverse, the same computation performs both encryption and decryption.
	\item \textbf{Block Ciphers}: This takes as input a secret key and a plaintext block of fixed size (older ciphers used 64-bit blocks, modern ciphers use 128-bit blocks). It produces a ciphertext block the same size as the plaintext block. To encrypt messages larger than the blocksize, the block cipher is used iteratively with algorithms called \textit{modes of operation}. A block cipher also has a decryption operation that does the reverse computation.
	\end{itemize}
	So, block ciphers encrypt data in blocks of set lengths, while stream ciphers do not and instead encrypt plaintext one byte at a time. The two encryption approaches, therefore, vary widely in implementation and use cases.\\
	Here we will have some prerequisite concepts and then we will dive into these two encryption algorithms}

	\newpage
	\subsection{Finite Fields}
	\todo{Finite Fields}
	
	\newpage
	\subsection{Per-Round Keys}
	\todo{Per-Round Keys}
		
	\newpage
	\subsection{S-boxes and Bit Shuffles}
	\todo{Write S-boxes and Bit Shuffles}

	\newpage
	\subsection{Feistel Cipher} \label{feistel-cipher}
	\configuratedText{It is very important to make the encryption algorithm revered so that the decryption is possible. One method (used by AES) of having a cipher is to make all components reversible. With DES, the S-boxes are clearly not reversible since they map 6-bit inputs to 4-bit outputs. So instead, DES is designed to be reversible using a clever technique known as a Feistel cipher.\\
	A Feistel cipher builds reversible transformations out of one-way transformations by only working on half the bits of the input value at a time. let us assume a 64-bit input block. \figref{feistel-cipher} shows both how encryption and decryption work. In a Feistel cipher there is some irreversible component that scrambles the input. We’ll call that component the mangler function.\\
	In encryption for round n, the 64-bit input to round $n$ is divided into two 32-bit halves called $L_{n}$ and $R_{n}$. Round n generates as output 32-bit quantities $L_{n+1}$ and $R_{n+1}$. The concatenation of $L_{n+1}$ and $R_{n+1}$ is the 64-bit output of round n and, if there’s another round, the input to round n+1. $L_{n+1}$ is simply $R_{n}$. To compute $R_{n+1}$, do the following. $R_{n}$ and $K_{n}$ are input to the mangler
	function, which takes as input 32 bits of data plus some bits of key to produce a 32-bit output. The 32-bit output of the mangler is XORed with $L_{n}$ to obtain $R_{n+1}$.}
	\sectionCenteredfigure{\FeistelCipher}{Feistel Cipher}{feistel-cipher}
	
	\newpage
	\subsection{Padding and Ciphertext Stealing}
	\configuratedText{Padding and ciphertext stealing are techniques used in cryptography to handle messages or plaintext that are not an exact multiple of the block size in block cipher algorithms. Both techniques serve the purpose of ensuring proper encryption and decryption while maintaining the integrity and length of the ciphertext.\\
	
	\textbf{Padding}:\\
	Padding is the process of adding extra bits or bytes to the plaintext before encryption to ensure it aligns with the block size required by the encryption algorithm. The most commonly used padding scheme is called PKCS\#7 (Public Key Cryptography Standard \#7).
	
	In PKCS\#7 padding, if the plaintext is shorter than the block size, padding bytes are added to the end of the plaintext. The value of each padding byte is set to the number of padding bytes added. For example, if two bytes are needed to reach the block size, both padding bytes will have a value of 0x02.
	
	During decryption, the receiver knows the number of padding bytes based on the value of the last byte in the decrypted block. The padding bytes are then removed to obtain the original plaintext.
	
	Padding is effective when the plaintext length is an exact multiple of the block size, but it introduces additional bytes to the ciphertext, which might impact certain protocols or applications where maintaining the exact plaintext length is crucial.\\
	
	\textbf{Ciphertext Stealing}:\\
	Ciphertext stealing is an alternative approach to handle the last partial block of plaintext without explicitly padding it. It is commonly used when the plaintext length is not a perfect multiple of the block size.
	
	In ciphertext stealing, the last block of plaintext is divided into two parts: a truncated part and a stolen part.
	
	The truncated part consists of the initial bytes of the last block that can fill up a complete block size. This truncated part is encrypted like any other block and becomes the second-to-last block of ciphertext.
	
	The stolen part consists of the remaining bytes in the last block. It is then combined with the second-to-last block of ciphertext to create the final block of ciphertext.
	
	During decryption, the last block of ciphertext is decrypted as usual. The stolen part is separated from the decrypted last block, and it is combined with the second-to-last block of plaintext to recover the original message.
	
	Ciphertext stealing allows for encryption and decryption of messages of varying lengths without explicitly padding the last block. It ensures that the ciphertext remains the same length as the original plaintext, which can be desirable in certain scenarios.
	
	Figure \figref{cbc-cs1-encrypt} below illustrates the CBC-CS1-Encrypt algorithm for the case that $ P_{n}^{*} $ is a partial block, i.e., d $ \le $ b. The bolded rectangles contain the inputs and outputs.
	The dotted rectangles provide alternate representations of two blocks in order to illustrate the role of the “stolen” ciphertext.
	In particular, the string of the b-d rightmost bits of $ C_{n-1} $ , denoted $ P_{n-1}^{**} $, becomes the padding for the input block to the final invocation of the block cipher within the execution of CBC mode. The ciphertext that is returned in Step 5 above omits $ C_{n-1}^{**} $, because it can be recovered from $ C_{n} $ during decryption.
	
	\sectionCenteredfigure[0.65]{\CBCCSEncrypt}{CBC CS1 Encrypt}{cbc-cs1-encrypt}

	}
	
	\newpage
	\subsection{Stream Ciphers}
	\configuratedText{Idea: try to simulate one-time pad\\
	A stream cipher encrypts a continuous string of binary digits by applying time-varying transformations on plaintext data. Therefore, this type of encryption works bit-by-bit, using keystreams to generate ciphertext for arbitrary lengths of plain text messages. The cipher combines a key (128/256 bits) and a nonce digit (64-128 bits) to produce the \textbf{keystream} — a pseudorandom number XORed with the plaintext to produce ciphertext. While the key and the nonce can be reused, the keystream has to be unique for each encryption iteration to ensure security. Stream encryption ciphers achieve this using feedback shift registers to generate a \textbf{unique nonce (number used only once) to create the keystream}.\\\\
	Encryption schemes that use stream ciphers are less likely to propagate system-wide errors since an error in the translation of one bit does not typically affect the entire plaintext block. Stream encryption also occurs in a \textbf{linear, continuous manner}, making it simpler and faster to implement. On the other hand, stream ciphers lack diffusion since each plaintext digit is mapped to one ciphertext output. Additionally, they do not validate authenticity, making them vulnerable to insertions. If hackers break the encryption algorithm, they can insert or modify the encrypted message without detection. Stream ciphers are mainly used to encrypt data in applications where the amount of plain text cannot be determined and in low latency use-cases.}
	
	\newpage
	\subsection{Types of Stream Ciphers}
	\configuratedText{
	Stream ciphers fall into two categories:\\
	
	\textbf{Synchronous Stream Ciphers:}
	
	\begin{itemize}
		\item  In a synchronous stream cipher, the keystream block is generated independently of the previous ciphertext and plaintext messages. This means that \textbf{each keystream block is generated based only on the key} and does not depend on any previous blocks.
		\item 	The most common stream cipher modes use pseudorandom number generators (PRNGs) to create a string of bits, which is combined with the key to form the keystream.
		\item 	The keystream is then XORed with the plaintext to generate the ciphertext.
	\end{itemize}
	
	Self-Synchronizing/Asynchronous Stream Ciphers:
	
	\begin{itemize}
		\item 	A self-synchronizing stream cipher, also known as ciphertext autokey, \textbf{generates the keystream block as a function of both the symmetric key and the fixed-size (N-bits) previous ciphertext block}.
		\item 	By altering the ciphertext, the content of the next keystream is changed. This property allows self-synchronizing ciphers to detect active attacks because any modification to the ciphertext will affect the decryption of subsequent blocks, making it easier to detect tampering.
		\item 	Asynchronous stream ciphers also provide limited error propagation. If there is a single-digit error in the ciphertext, it can affect at most N bits (the size of the previous ciphertext block) in the next keystream block
	\end{itemize}.}
	
	\subsection{Stream Ciphers in practice}
	\configuratedText{popular encryption schemes that use stream ciphers include:}
	\subsubsection{A5/1}
	\subsubsection{Rivest Cipher (RC4)}
	\subsubsection{Salsa20}
	
	\newpage
	\subsection{Block Ciphers}
	\configuratedText{Block ciphers convert data in plaintext into ciphertext in fixed-size blocks. The block size generally depends on the encryption scheme and is usually in octaves (64-bit or 128-bit blocks). If the plaintext length is not a multiple of 8, the encryption scheme uses \textbf{padding} to ensure complete blocks. For instance, to perform 128-bit encryption on a 150-bit plaintext, the encryption scheme provides two blocks, 1 with 128 bits and one with the 22 bits left. 106 Redundant bits are added to the last block to make the entire block equal to the encryption scheme’s ciphertext block size.\\\\
	While Block ciphers use symmetric keys and algorithms to perform data encryption and decryption, they also require an \textbf{initialization vector (IV)} to function. An initialization vector is a pseudorandom or random sequence of characters used to encrypt the first block of characters in the plaintext block. The resultant ciphertext for the first block of characters acts as the initialization vector for the subsequent blocks. Therefore, the symmetric cipher produces a unique ciphertext block for each iteration while the IV is transmitted along with the symmetric key and does not require encryption.\\\\
	Block encryption algorithms offer \textbf{high diffusion}; that is, if a single plaintext block were subjected to multiple encryption iterations, it resulted in a unique ciphertext block for each iteration. This makes the encryption scheme relatively tamper-proof since it is difficult for malicious actors to insert symbols into a data block without detection. On the other hand, block ciphers have a \textbf{high error propagation rate} since a bit of change in the original plaintext results in entirely different ciphertext blocks.}

	\subsection{Block Ciphers in practice}
	\subsubsection{Data Encryption Standard (DES)}
	\configuratedText{DES is a symmetric block cipher using 64 bit blocks and 56 bits key.\\
	The choice of using 56 bits for keys in DES was a compromise between security and practicality. While a longer key would provide stronger security, the designers of DES also needed to consider the limitations of computing technology at the time. The inclusion of 8 parity bits reduced the effective key size to 56 bits, which some experts even then considered inadequate for robust security. However, the decision to use a 56-bit key was likely influenced by a balance between security requirements and the feasibility of implementing and processing longer keys with the available hardware during that era.}
	\sectionCenteredfigure{\DESStructure}{Basic Structure of DE}{basic-structure-of-des}
	
	\subsubsection{DES Overview}
	\configuratedText{First, the 64-bit input is subjected to an initial bit-shuffle. Then, 56-bit key is expanded into sixteen 48-bit per-round keys by taking a 48-bit subset of the 56-bit input key for each of the keys. Each round takes a 64-bit input with a 48-bit key and produces a 64-bit cipher block. After the sixteenth round, the output has its halves swapped and then is subjected to another bit-shuffle which happens to be the inverse of the initial bit-shuffle. This swapping after the final round does not add any cryptographic strength but has a side benefit. As noted in Feistel Ciphers, Swapping the output make the encryption and description identical except for the key schedule}
	
	\subsubsection{DES Complementary Notes}
	\configuratedText{\textbf{The Mangler Function}\todo{Add DES Mangler Function}\\ 
	\textbf{Undesirable Symmetries}\todo{Add DES Undesirable}\\ 
	\textbf{DES Variants}\todo{Add DES Variantss}\\}
	
	\subsubsection{Advanced Encryption Standard (AES)}
	\configuratedText{AES is a symmetric block cipher using 128 bit blocks and 128, 192 or 256 bits key with the resulting variants called AES-128, AES-192, and AES-256.\\
	AES is similar to DES in that there is a key expansion algorithm which takes the key as an input and expands it into a bunch of round keys, and the algorithm executes a series of rounds that mangle a plaintext block into a ciphertext block. \figref{basic-structure-of-aes}. With DES each round it takes a 64-bit input with a 48-bit key and outputs 64-bit that (along with the next round key) is fed to the next round. With AES, each round takes a 128-bit input and a 128-bit key and produces a 128-bit output which is the input to the next round. Unlike DES, AES is not Feistel cipher. (The Feistel cipher structure is characterized by the division of the plaintext into two halves and the repeated application of a round function that involves both halves. Read more here: \ref{feistel-cipher})\\
	In accordance to do as many rounds as needed to make the exhaustive search cheaper than any other form of cryptanalysis, AES does more round with bigger keys. AES-128 has 10 rounds, AES-196 has 12 rounds and AES-256 has 14 rounds. If AES
	had a 64-bit version, it would have eight rounds, which would be comparable to the sixteen rounds in DES.\\
	Another diffference between DES and AES is that DES operates on bits where AES operates on octets (bytes)\\
	In AES, the key (128, 192, or 256 bits) is expanded into a series of 128-bit round keys, where there is one more round key than there are rounds. AES encryption or decryption consists of $\oplus$ing a round key into the intermediate value at the beginning of the process, at the end of the process, and between each pair of rounds.\\
	In terms of Substitution and Permutation and cryptographic transformations, DES relies on predefined tables for S-boxes and P-boxes, which may appear arbitrary without understanding their rationale. In contrast, AES provides simpler mathematical formulas for substitutions and permutations, openly stating the reasons behind their design choices.}
	
	
	\sectionCenteredfigure{\AESStructure}{Basic Structure of AE}{basic-structure-of-aes}
	
	\subsubsection{AES Complementary Notes}
	\configuratedText{\textbf{(AES’s S-box)}\todo{Add AES S-Box}\\ 
	\textbf{Key expansion}\todo{Add AES Key expansion}\\ }

	\subsection{Block Ciphers Modes of Operations}
	\configuratedText{Block ciphers operate on fixed-length blocks, typically 64 or 128 bits. The reason for using fixed-length blocks is twofold: first, messages can have varying lengths, and second, encrypting the same plaintext with the same key should always produce the same output.\\
	To address the need for encrypting messages of \textbf{arbitrary} lengths, several modes of operation have been invented. These modes allow block ciphers to provide confidentiality for messages of any length. These modes define how the block cipher is applied to multiple blocks and how they are combined to encrypt or decrypt the entire message.}

	\subsubsection{Electronic Cook Book (ECB)}
	\configuratedText{a full 128 bits), and encrypt each block
	with the secret key \figref{electronic-code-book-encryption}. The other side receives the encrypted blocks and decrypts each block in turn to recover the original message \figref{electronic-code-book-decryption}.}

	\sectionCenteredfigure{\ECBEncryption}{Electronic Code Book Encryption}{electronic-code-book-encryption}
	
	\sectionCenteredfigure{\ECBDecryption}{Electronic Code Book Decryption}{electronic-code-book-decryption}
	
	\configuratedText{ECB has two serious flaws. Patterns in the ciphertext, such as repeated blocks, leak information, and nothing prevents someone from rearranging, deleting, modifying, or duplicating blocks.}
	
	\sectionCenteredfigure[0.7]{\ECBDiffusion}{ECB Lack of Diffusion}{ecb-lack-of-diffusion}
	
	\subsubsection{Cipher Block Chaining (CBC)}
	\configuratedText{CBC generates its own “random numbers” for all but the first block. It uses $ c_{i} $ as $ r_{i+1} $. In other words, it takes the previous block of ciphertext and uses that as the “random
	number” that will be $\oplus$’d into the next plaintext block. To avoid leaking the information that two messages encrypted with the same key have the same first plaintext blocks, CBC selects one random number that gets $\oplus$’d into the first block of plaintext and transmits it along with the data.\\
	This initial random number is known as an \textbf{IV (initialization vector)}
	A randomly chosen IV guarantees that even if the same message is sent repeatedly, the ciphertext will be completely different each time.}
	\sectionCenteredfigure{\CBCEncrption}{Cipher Block Chaining Encryption}{cipher-block-chaining-encryption}
	\configuratedText{\textbf{Properties of CBC:}
	\begin{itemize}
	\item What would happen if they changed a block of the ciphertext, say, the value of ciphertext block $ c_{n} $? Changing $ c_{n} $ has a predictable effect on $ m_{n+1} $ because $ c_{n} $ gets $\oplus$’d with the decrypted $ c_{n+1} $ to yield $ m_{n+1} $ For instance, changing bit 3 of $ c_{n} $ changes bit 3 of $ m_{n+1} $. Modifying $ c_{n} $ also garbles block $ m_{n} $ to some unpredictable
	value.
	\item Asynchronous stream cipher
	\item Conceals plaintext patterns
	\item Plaintext cannot be easily manipulated
	\item No parallel implementation known for encryption
	\item message must be padded to a multiple of the cipher block size (or we may use Ciphertext Stealing)
	\item a plaintext can be recovered from just two adjacent blocks of ciphertext\\ as a consequence, decryption can be parallelized. usually a message is encrypted once, but decrypted many times
	\end{itemize}
	
	}

	\subsubsection{XEX (XOR Encrypt XOR)}
	\todo{Write down XEX}
	
	\subsubsection{XTS (XEX with Ciphertext Stealing)}
	\configuratedText{XTS is a clever variant of XEX that encrypts multiblock messages that need not be a multiple of the cryptographic blocksize while still keeping the ciphertext the same
	size as the plaintext. XTS accomplishes this goal (of being length-preserving despite a message not being a multiple of the cryptographic blocksize) through a very clever but somewhat complicated trick known as ciphertext stealing.\\ Ciphertext stealing pads the final block $ m_{n} $ with as many of the bits of the previous block of
	ciphertext ($ c_{n-1} $) as necessary to make block $ m_{n} $ be full sized (in our example, $ 128 - 93 = 35 $ bits need to be stolen from $ c_{n-1} $). The padded block $ m_{n} $ is then encrypted. But the ciphertext is now longer than the plaintext, since the last block of ciphertext is now a full-sized block. To solve that problem, we swap ciphertext blocks $ c_{n} $ and $ c_{n-1} $ and truncate the final
	ciphertext block (which was the encryption of block $ m_{n-1} $) to be the size of the original block $ m_{n} $. In our example, where the original block mn was 93 bits long, the final ciphertext block will be 93 bits.
	Now the ciphertext is the same size as the message, but how do we decrypt either of the last two blocks? To obtain block $ m_{n} $, decrypt $ c_{n-1} $ (using implicit IVs and Bmods associated with block $ m_{n} $).
	The result will be plaintext $ m_{n} $ with appended padding, but you need to know how much of the result is message and how much is padding. The size of plaintext block $ m_{n} $ will be the size of the final ciphertext block (in our example, 93 bits). The padding (the remaining 128-93=35 bits) is stolen ciphertext from $ c_{n-1} $.}
	\sectionCenteredfigure{\XTSEnryption}{XTS Mode Decryption}{xts-mode-decryption}
	\sectionCenteredfigure{\XTSDecryption}{XTS Mode Decryption}{xts-mode-decryption}	
	
	\subsubsection{Cipher Feedback (CFB)}
	\configuratedText{CFB (short for cipher feedback) is an AES block cipher mode like CBC, makes a block cipher into an asynchronous stream cipher (i.e., supports some re-synchronizing after error, if input to encryptor is given through a shift-register) in the sense that for the encryption of a block, $ B_{i} $, the cipher of the previous block, $ C_{i-1} $ is required. CFB also makes use of an initialization vector like CBC. The main difference is that in CFB, the ciphertext block of the previous block is encrypted first and then XOR-ed with the block in focus.}
	\sectionCenteredfigure[0.7]{\CFBCSEncrypt}{Cipher Feedback (CFB)}{cipher-feedback-cfb}

	\subsubsection{Output Feedback (OFB)}
	\configuratedText{The output feedback (OFB) mode makes a block cipher into a synchronous stream cipher. It generates keystream blocks, which are then XORed with the plaintext blocks to get the ciphertext. Just as with other stream ciphers, flipping a bit in the ciphertext produces a flipped bit in the plaintext at the same location. This property allows many error-correcting codes to function normally even when applied before encryption.\\
	\textbf{Properties of OFB:}
	\begin{itemize}
	\item 	 Synchronous stream cipher
	\item 	 Errors in ciphertext do not propagate
	\item 	 Pre-processing is possible
	\item 	 Conceals plaintext patterns
	\item 	 No parallel implementation known
	\item 	 Active attacks by manipulating plaintext are possible
	\end{itemize}
	}
	\sectionCenteredfigure{\OFBCSEncrypt}{Feedback (OFB)}{output-feedback-ofb}

	\subsubsection{Counter Mode (CTR)}
	\configuratedText{also known as Integer Counter Mode (ICM) and
	Segmented Integer Counter (SIC) mode 
	\begin{itemize}
	\item 	turns a block cipher into a stream cipher: it generates the next keystream block by encrypting successive values of a "counter" 
	\item 	counter can be any function which produces a sequence which is guaranteed not to repeat for a long time, although an actual counter is the simplest and most popular.
	\item 	the usage of a simple deterministic input function raised controversial discussions 
	\item 	has similar characteristics to OFB, but also allows a random access property during decryption
	\item 	well suited to operation on a multi-processor machine where blocks can be encrypted in parallel
	\end{itemize}}
	\sectionCenteredfigure{\CTREncrption}{Counter Mode (CTR)}{counter-mode-ctr}
		
	\newpage
	\section{Data Integrity}
	\configuratedText{A secret key system can be used to generate a cryptographic integrity check known as a MAC (Message Authentication Code). MACs are used to protect the data from modification in transit.\\ In this chapter, we’ll focus on MACs based on secret key encryption functions and MACs based on hash functions.}
	
	\subsection{Definition}
	\configuratedText{
	\begin{itemize}
	\item \textit{Authentication  Algorithm} (A): $A$ is the algorithm used to generate an authentication tag for a given message using a secret authentication key (k). It takes the message (m) as input and produces the authentication tag $ A_{k}(m) $.
	\item \textit{Verification Algorithm} (V): $V$ is the algorithm used to verify the authenticity and integrity of a message. It takes the received message $(m)$ and its corresponding authentication tag $(A_k(m))$ as input and outputs either \textit{accept} or \textit{reject} based on whether the authentication tag is valid or not.
	\item \textit{Authentication Key} ($k$): The authentication key $(k)$ is a secret key shared between Alice and Bob. It is used by the authentication algorithm $(A)$ to generate the authentication tag and by the verification algorithm $(V)$ to validate the tag.
	\item \textit{Message Space (usually binary strings)}: The message space refers to the set of possible messages that can be authenticated using CBC-MAC. Typically, these messages are represented as binary strings.
	\item \textit{Message Format}: Every message exchanged between Alice and Bob is a pair $(m, A_k(m))$, where $m$ is the actual message and $A_k(m)$ is its corresponding authentication tag generated by applying the authentication algorithm $(A)$ with the authentication key $(k)$.
	\end{itemize}
	}
	        
	\subsection{MAC based on CBC Mode Encryption}
	\configuratedText{CBC-MAC computes a MAC of a message using key K. It encrypts the message in CBC mode, using key K, and uses the last block (called the \textbf{residue}, see \figref{cipher-block-chaining-residue}) as the MAC for the message. If an attacker modifies any portion of a message, the residue will no longer be the correct value (except with probability 1 in $ 2^{128} $, assuming 128-bit blocks).}
	\sectionCenteredfigure{\CBCMACResidue}{Cipher Block Chaining Residue}{cipher-block-chaining-residue}

	
	\subsection{Vulnerabilities of CBC-MAC}
	\subsubsection{Initialization Vector or IV}	
	\configuratedText{When we are working on CBC-MAC or Cipher Block Chaining Message Authentication Code, we generally use the Initialization Vector or IV as zero.\\
	When we use the IV or Initialization Vector as zero, a problem arises. Let's say there are two known messages named 'msg1' and 'msg2'. These two messages will generate two signatures called 'sig1' and 'sig2' independently. Finally,
	
	\begin{itemize}
	\item 	    E (msg1 XOR 0) = sig1    
	\item 	    E (msg2 XOR 0) = sig2
	\end{itemize}
	    
	Now, a message which consists of msg1 and msg2 will generate two signatures. Let's name the concatenated message as msg3 and the signals generated as sig31 and sig32. 
	
	\begin{itemize}
	\item 	    E (msg1 XOR 0) = sig31 = sig1
	\item 	    E (msg2 XOR sig1) = sig32
	\end{itemize}
	     
	We can calculate this without even knowing the key of the encryption. }
	
	\subsubsection{Fixed and Variable-length message}
	\configuratedText{If the block cipher used is secure (meaning that it is a pseudorandom permutation), then CBC-MAC is secure for fixed-length messages. However, by itself, it is not secure for variable-length messages. Thus, any single key must only be used for messages of a fixed and known length. This is because an attacker who knows the correct authentication tag (i.e. CBC-MAC) pairs for two messages (m,t) and (m',t') can generate a third message m" whose CBC-MAC will also be t'. This is simply done by XORing the first block of m' with t and then concatenating m with this modified m'; i.e., by making $ m" = m \parallel (m_{1}' \oplus t) \parallel m_{2}' \parallel \dots \parallel m_{x}'$\\
	There are three main ways of modifying CBC-MAC so that it is secure for variable length messages: 
	\begin{enumerate}
		\item 	Input-length key separation
		\item 	Length-prepending
		\item 	Encrypt last block.
		\item 	Use HMACs or CMACs.
	\end{enumerate}}
	
	\subsection{MAC based on cryptographic hash}
	\configuratedText{A hash function inputs an arbitrary-sized bitstring and outputs a fixed-size bitstring, ideally so that
	all output values are equally likely. A cryptographic hash (also known as a message digest) has some extra security properties:
	
	\textbf{Preimage Resistance}: It should be computationally infeasible to find a message that has a given pre-specified hash.
	
	\textbf{Collision Resistance}: It should be computationally infeasible to find two messages that have the same hash.
	
	\textbf{Second Preimage Resistance}: It should be computationally infeasible to find a second message that has the same hash as a given message.\\}
	
	\configuratedText{Strong collision resistance: A hash function is said to have strong collision resistance if it is computationally infeasible to find \textbf{any two distinct inputs} that produce the same hash output. In other words, given a hash value h, it is difficult to find any two different messages m1 and m2 such that hash(m1) = hash(m2).
		
	Weak collision resistance (also known as second preimage resistance): A hash function is said to have weak collision resistance if it is computationally infeasible \textbf{to find a second input message that produces the same hash output as a given fixed input message.} In simpler terms, it is difficult to find a different message m2 such that hash(m1) = hash(m2) for a known message m1.\\
		
	The strong collision resistance property implies the weak collision resistance property (strong $\rightarrow$ weak). For the proof we show $not$ Weak $\rightarrow$ $not$ Strong If a hash function is strongly collision resistant, it automatically implies that it is weakly collision resistant. If it were possible to find a second preimage for a fixed input message, it would effectively mean finding a collision between the fixed input message and the second preimage, contradicting the strong collision resistance assumption. Therefore, a hash function that exhibits strong collision resistance will inherently exhibit weak collision resistance as well.
		
	As an example, the mod s function (\% s), where s is a large random prime number, is not suitable for cryptographic purposes due to the following reasons:
		
	a) Predictability: The mod s function is deterministic and has a predictable output. Given an input x, the output of x \% s will always be the remainder when x is divided by s. This predictability makes it vulnerable to attacks, as an attacker can calculate the output for various inputs and try to identify patterns or predict future outputs.
		
	b) Lack of diffusion: Cryptographic hash functions need to exhibit the property of diffusion, which means that a small change in the input should result in a significantly different output. However, the mod s function does not provide diffusion. If two inputs x1 and x2 are very close to each other (e.g., x2 = x1 + 1), their outputs x1 \% s and x2 \% s will also be very close to each other, thus lacking the necessary diffusion property.
		
	Limited output space: The output of the mod s function is constrained to the range from 0 to s-1, where s is the prime number. This limited output space makes it vulnerable to brute-force attacks, where an attacker can exhaustively try different inputs until finding a collision or a preimage.
		
	Lack of resistance to mathematical attacks: The mod s function is vulnerable to various mathematical attacks, such as modular arithmetic properties or number-theoretic attacks. These attacks exploit the specific properties of modular arithmetic and the structure of prime numbers, making the function unsuitable for cryptographic purposes.}

	\subsection{The Birthday Paradox}
	\configuratedText{If there are 23 or more people in a room, the odds are better than 50\% that two of them will have the same birthday. Analyzing this parlor trick can give us some insight into cryptography.\\ Let's do this in a slightly more general way. Let's assume $n$ inputs (which would be humans in the birthday example), $k$ possible outputs, and an unpredictable mapping from input to output. With $n$ inputs, there are $\frac{n(n-1)}{2}$ pairs of inputs. For each pair, there's a probability of $\frac{1}{k}$ of both inputs producing the same output value. Therefore, you'll need about $\frac{k}{2}$ pairs in order for the probability to be about $\frac{1}{2}$ that you'll find a matching pair. That means that if $n$ is greater than $\frac{k}{2}$, there's a good chance of finding a matching pair.}
	
	\subsection{MACs based on Hash Functions}
	
	\subsection{SHA-1}
	
	\newpage
	\subsection{Authenticated Encryption (AE)}
	\configuratedText{Authenticated Encryption (AE) is an encryption scheme which simultaneously assures the data confidentiality (also known as privacy: encrypted message is impossible to understand without the knowledge of a secret key) and authenticity (in other words, it is unforgeable: the encrypted message includes an authentication tag that the sender can calculate only if she possesses the secret key)
		
	Many (but not all) AE schemes allow the message to contain "associated data" (AD) which is not made confidential, but its integrity is protected (i.e., it is readable, but tampering with it will be detected). A typical example is the header of a network packet that contains its destination address. To properly route the packet, all intermediate nodes in the message path need to know the destination, but for security reasons they cannot possess the secret key. Schemes that allow associated data provide authenticated encryption with associated data, or AEAD.}

	\subsubsection{Encrypt-then-MAC (E$t$M)}
	\configuratedText{The plaintext is first encrypted, then a MAC is produced based on the resulting ciphertext. The ciphertext and its MAC are sent together. Used in, e.g., IPsec. This is the only method which can reach the highest definition of security in AE, but this can only be achieved when the MAC used is "strongly unforgeable". Note that key separation is mandatory (distinct keys must be used for encryption and for the keyed hash), otherwise it is potentially insecure depending on the specific encryption method and hash function used.}
	
	\sectionCenteredfigure[0.6]{\AEEtM}{Authenticated Encryption EtM}{ae-etm}
	
	\subsubsection{Encrypt-and-MAC (E$\&$M)}
	\configuratedText{A MAC is produced based on the plaintext, and the plaintext is encrypted without the MAC. The plaintext's MAC and the ciphertext are sent together. Used in, e.g., SSH. Even though the E\&M approach has not been proved to be strongly unforgeable in itself, it is possible to apply some minor modifications to SSH to make it strongly unforgeable despite the approach.}
	
	\sectionCenteredfigure[0.6]{\AEEaM}{Authenticated Encryption EaM}{ae-eam}
	
	\subsubsection{MAC-then-Encrypt (M$t$E)}
	\configuratedText{A MAC is produced based on the plaintext, then the plaintext and MAC are together encrypted to produce a ciphertext based on both. The ciphertext (containing an encrypted MAC) is sent. AEAD is used in SSL/TLS. Even though the MtE approach has not been proven to be strongly unforgeable in itself,[15] the SSL/TLS implementation has been proven to be strongly unforgeable by Krawczyk who showed that SSL/TLS was, in fact, secure because of the encoding used alongside the MtE mechanism. Despite the theoretical security, deeper analysis of SSL/TLS modeled the protection as MAC-then-pad-then-encrypt, i.e. the plaintext is first padded to the block size of the encryption function. Padding errors often result in the detectable errors on the recipient's side, which in turn lead to padding oracle attacks, such as Lucky Thirteen.\\ AEAD is a cryptographic construction that combines both encryption and authentication in a single operation.}
	
	\sectionCenteredfigure[0.5]{\AEMtE}{Authenticated Encryption MtE}{ae-mte}

	\newpage
	\section{Public Key Cryptography}
	
	\newpage
	\subsection{RSA}
	\configuratedText{RSA is named after its inventors, Rivest, Shamir, and Adleman. The real premise behind RSA’s security is the assumption that factoring a big number is hard.}
	
	\subsubsection{Example}
	\configuratedText{First, we pick two big prime numbers $p$ and $q$.
	\begin{enumerate}
	\item $p = 2, q = 7$
	
	Then we will calculate the multiplication of q and p.
	
	\item $p \times q  = 14$
	
	Now, we calculate $\phi$ function: $\phi = (p-1)(q-1)$
	
	\item $\phi = 1 \times 6 = 6$
	
	Now, we need to choose a value $e$ having the following conditions:
	\begin{itemize}
		\item $1 < e < \phi(n)$
		\item e should be prime with respect to $n$ and $\phi(n)$
	\end{itemize}

	\item $e = 5$
	
	Finally, we choose a number under the following condition:
	$d \times e ( mod \phi ( n )) = 1$
	 
	\item $d = 11$
	
	Finally, we have the following numbers:n = 14 ,e = 5 ,d = 11\\
	Based on RSA, we use $e$ and $n$ as the public-key and $e$ and $d$ as the private-key.
	\end{enumerate}

	Now, assume we want to send the number $2$ to our friend. Having our fiend's public-key which has been sent to use before (5,14) we first calculate\\ $2^5 mod 14 = 4$\\
	Now, our encrypted message is $4$. We send $4$ to our friend.\\
	Our friend, with his private-key (11, 14) decrypts the message:\\ $4^{11} mod 14 = 2$}

	\newpage
	\subsection{Diffie-Hellman}
	\configuratedText{Diffie-Hellman allows two individuals (Alice and Bob) to agree on a shared key even though they can only exchange messages in public.\\ he security of Diffie-Hellman depends on the difficulty of solving the discrete log problem,
	which can be informally stated as, “If you know $g$, $p$, and $g^{x} mod p$, what is x?” In other words, what exponent did you have to raise $g$ to, $mod p$, to get $g^{x}$?\\ 
	So, there are integers $p$ and $g$, where $p$ is a large prime (say 2048 bits) and $g$ is a number less than p with some restrictions that aren’t too important for a basic understanding of the algorithm.\\
	The values $p$ and $g$ are known beforehand and can be publicly known, or Alice and Bob can negotiate with each other across the crowded room.\\
	Once Alice and Bob agree on a $p$ and $g$, each chooses a large, say, 512-bit number at random and keeps it secret. Let’s call Alice’s private Diffie-Hellman key $a$ and Bob’s private
	Diffie-Hellman key $b$. Each raises $g$ to their private Diffie-Hellman number, $mod p$, resulting in their public Diffie-Hellman value. So Alice computes $g^{a} mod p$ and Bob computes $g^{b} mod p$, and each informs the other. Finally, each raises the other side’s public value to their own
	private value.}

	\sectionCenteredfigure[0.7]{\dhprotocol}{Diffie-Hellman Exchange}{diffie-hellman-exchange}
	
	\configuratedText{Alice raises $g^b mod p$ to her private number $a$. Bob raises $g^a mod p$ to his private number $b$. So Alice computes $(g^b mod p)^a = g^{ba} mod p$. Bob computes $(g^a mod p)^b = g^{ab} mod p$. And, of course, $g^{ba} mod p = g^{ab} mod p$.\\
	Without knowing either Alice’s private number $a$ or Bob’s private number $b$, nobody else can calculate $g^{ab} mod p$ in a reasonable amount of time even though they can see $g^a mod p$ and $g^b mod p$.
	}
	
	\newpage
	\subsection{Digital Signatures}
	
	\newpage
	\section{Cryptographically Secure Pseudo-Random Number Generators}
	
	\newpage
	\section{Authentication}
	
	\newpage
	\section{Secret Sharing}

	\newpage
	\section{Access Control}

	\newpage
	\section{Secure Protocols}
	
	\newpage
	\section{Firewalls}

	\newpage
	\section{Email Security}

	\newpage
	\section{Web Technologies}	
	
	\newpage
	\section{Web Security}	
	
	\newpage
	\section{Web Tracking}	
		
\end{document}